# 多路复用模型

在IO模型中,有一种多路复用的模型

![](http://imageblog.boyn.top/202001291844_443.png)

在Linux下,`select`,`poll`,`epoll`都是用来实现这个模型的,但是这三个机制又有不同

# select

在select函数中,有一个数据结构`fd_set`,它是一个文件描述符.

select调用过程如图所示

![](http://imageblog.boyn.top/202002022040_46.png)

首先我们会打开连接并初始化IO,然后我们将这个IO所对应的文件描述符放入`fd_set`中,在select函数中,可以传入的是文件描述符的数组,我们可以同时传入多个文件描述符.

在select函数调用过程中,首先会将fd_set整个数组复制到内核空间中,并为每个fd_set注册一个回调函数.

遍历fd_set,调用回调函数,其作用就是监听IO事件是否完成,直到完成了,才会返回,在没完成之前,会将进程挂在等待队列上.

**select的几大缺点：**

**（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大**

**（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大**

**（3）select支持的文件描述符数量太小了，默认是1024**

# poll

poll与select在底层的实现类似,只是poll在传入文件描述符的时候是链表类的结构

 select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替 

# epoll

epoll是一个函数簇,提供了三个函数,epoll_create,epoll_ctl和epoll_wait

create是创建一个句柄

ctl是注册要监听的事件类型,在ctl函数中,注册新的事件时,只会拷贝一次,将fd放入内核

wait则是等待事件的产生

epoll是通过内核与用户空间mmap同一块内存实现的。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。

   红黑树将存储epoll所监听的套接字。上面mmap出来的内存如何保存epoll所监听的套接字，必然也得有一套数据结构，epoll在实现上采用红黑树去存储所有套接字，当添加或者删除一个套接字时（epoll_ctl），都在红黑树上去处理，红黑树本身插入和删除性能比较好，时间复杂度O(logN)。

 通过epoll_ctl函数添加进来的事件都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把事件添加进来的时候时候会完成关键的一步，那就是该事件都会与相应的设备（网卡）驱动程序建立回调关系，当相应的事件发生后，就会调用这个回调函数，该回调函数在内核中被称为：ep_poll_callback,**这个回调函数其实就所把这个事件添加到rdllist这个双向链表中**。一旦有事件发生，epoll就会将该事件添加到双向链表中。那么当我们调用epoll_wait时，epoll_wait只需要检查rdlist双向链表中是否有存在注册的事件，效率非常可观。这里也需要将发生了的事件复制到用户态内存中即可。 

![](http://imageblog.boyn.top/202002022122_184.png)