# Redis

## 数据结构与对象

### 简单动态字符串(SDS)

SDS在Redis中表示简单动态字符串,是String的数据结构

- 结构

在SDS中,有三个属性,`len`用于表示长度,`free`用于表示未使用数据的长度,`char[]`是实际存储字符串的数组

与C字符串一样,它末尾同样有一个`\0`

一个SDS实例如下所示

![](http://imageblog.boyn.top/202002021348_74.png)

- 空间重分配

当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间

而当需要对SDS空间进行部分释放的时候,并不会立即回收多余的字节,而是更新free的数量

### 链表

在Redis中,链表作为列表键的底层算法之一

- 链表与子节点

在Redis中,实现了一个双向链表,同时有前驱节点和后继结点的指针,可以通过这两个指针来组成一个双向链表

![](http://imageblog.boyn.top/202002021354_37.png)

并且对于一个链表而言,redis还有记录表头结点,表尾结点和表长度的属性,以及dup,free等函数,他们使用了函数指针的方式来声明,便于形成多态的特性

![](http://imageblog.boyn.top/202002021359_793.png)

### 字典

Redis中的字典是hash的底层结构,同时也是数据库组成的底层结构

- 哈希表结构

Redis中,哈希表是由若干结点,哈希表大小以及掩码和结点数组成的

![](http://imageblog.boyn.top/202002021404_59.png)

在table中,表示哈希表的结点,用了链地址法来防止哈希冲突,每一个结点都是链表的一个结点

结点的结构包含键值和指向下一个结点的指针,可以以此形成一个链表

下图就表示在一个表中,有两个哈希值相同的键值对,他们组成了一个链表用于防止冲突

![](http://imageblog.boyn.top/202002021407_962.png)

- 哈希算法

在新键添加和根据键来查询的时候,我们需要对键作哈希算法,获取其哈希值之后作地址掩码的处理,然后将其放到对应下标的数组中,并检查冲突

- 解决冲突

Redis使用链地址法来解决冲突

- 渐进式Rehash

在hash中,有两个哈希表,一个在平时并不会存储数据,只有当哈希表需要扩容时,才会使用它来进行渐进式Rehash的方法来扩容

![](http://imageblog.boyn.top/202002021418_846.png)

假设要扩容的时候,为了速度考虑,并不会暂时停止插入,而是采取边插入边扩容的方式

我们假设之间的表为表0,新表为表1,那么我们每次对这个表进行操作(插入,查找,删除)的时候,除了执行指定操作之外,还会rehash表0中的一个元素到表1中,直到表0完全为空,则将其空间释放

在rehash期间,查找操作会先在表0中查找,找不到了再去表1寻找,而新插入的元素只会插入表1中

### 跳表

Redis将跳表作为有序集合的底层实现之一,如果元素较多或者元素成员是比较长的字符串的时候,就会用跳表来作为有序集合的实现

![](http://imageblog.boyn.top/202002021430_287.png)

- 复杂度
- 跳跃表结点
- 跳跃表

### 整数集合

整数集合是集合键的底层实现之一

- 整数位数

整数集合中,有多种整数位16,32,64,用数组将其记录起来

- 整数升级

当我们要添加一个新的数字到整数集合中,会先对其位数进行判断,如果其大小大于整数集合现时的编码,就要先对集合进行位数升级,一共分为三步,根据新元素类型扩展底层数组的空间大小,将所有元素都转换为跟新元素一样的类型并维持其顺序放到新位置中,将新元素插入

- 整数降级

整数集合不支持降级,一旦升级了,就会一直维持这个级别

### 压缩列表

压缩列表是列表键和哈希表的底层实现之一

- 结构

压缩列表的结构如图所示

![](http://imageblog.boyn.top/202002021452_535.png)

- 压缩列表结点

每一个压缩列表的结点都可以表示一个整数值或者一个字节数组,都由三个部分组成,前一个结点的长度,编码类型,主体数据

- 连锁更新

我们在前面说到压缩列表结点的时候说到,它会保存前一个节点的长度,所以当有一个列表,他们的结点的长度都小于255,那么长度部分占用1个字节,但是如果我们在前面加入了一个长为5个字节的数组时,就会引发后面所有结点的长度更新,称之为连锁更新

### 对象

- 对象系统

在Redis中,并没有直接使用上面所说的数据结构来实现数据库,而是将其封装为对象,创建了对象系统

- 对象类型

对象系统中包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型

- 内存回收

Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存

## 数据库

### 数据库空间

在Redis中,一个服务会创建多个数据库空间,默认为16,这些空间是不互通的,每一个客户端都可以有自己的目标数据库,客户端有一个指针来指向某个数据库.

在一个数据库中,会有一个字典结构来保存所有的键值对

![](http://imageblog.boyn.top/202002021533_755.png)

### 持久化过程

- RDB持久化

RDB是持久化的一种办法,它将数据库保存为一个二进制文件,并且可以令数据库从这个文件中恢复

RDB机制在进行保存的时候,会阻塞服务器进程,使任何命令都不会请求,直到持久化完成为止

并且只有当AOF关闭的时候,才会使用RDB

- AOF持久化

AOF持久化与RDB最大的不同就是AOF是保存服务器执行的命令的,它保存着数据库执行的对状态修改的命令来记录数据库的状态,它会将命令文本先保存到缓冲区中,然后定期写入文件

## IO多路复用

### Reactor模型

Redis服务器使用了Reactor模型,对于网络请求,它使用了IO多路复用,监听所有的文件描述符,当所对应通道发生了读写事件后,就会调用对应事件的回调函数进行处理

这些事件会放入单线程的事件处理器中,对Redis的数据进行读写,由于是单线程处理的,所以避免了竞态条件,无需锁,而且所有数据都会放在内存中,所以十分快

![](http://imageblog.boyn.top/202002021723_750.png)