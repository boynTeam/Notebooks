# 数据库事务

## 事务并发带来的问题

### 脏读

脏读指的是一个事务`A`正在访问特定数据的时候,有另外的事务`B`对这个数据进行了修改,这个修改还没有提交的时候,事务`A`就已经可以读到这个数据了

### 不可重复读

不可重复读指的是一个事务`A`正在读取某范围数据,此时事务`B`对这些数据进行了修改并提交,然后`A`再读的时候,读到的数据就是不一样的了,这个称为不可重复读

### 幻读

幻读与不可重复读类似,不过不可重复读是指的修改,而幻读是事务`B`删除或插入了新数据

## 数据库的隔离级别

### 数据库的隔离级别

- Read Uncommited(读未提交)

	- 最低的隔离级别,可以读取到其他事务还未提交的数据,会造成脏读,不可重复读,幻读等问题

- Read Commited(读已提交)

	- 可以读取到其他事务已经提交了的数据,解决了脏读的问题,但造成不可重复读,幻读的问题

- Repeatable Read(可重复读)

	- 保证在一次事务中,读取到的内容都是一致的,解决脏读,不可重复读,但是会带来脏读

- Serializable(序列化)

	- 完全禁止并发事务,同一时刻,同一张表只允许一个事务在进行

## 什么是事务

对于数据库来说,事务就是一系列操作的集合,比如我们需要从数据库中多次插入,多次查询,为了保证这些操作都成功并且不被干扰,我们就要将其作为一个事务

## 事务特性

### A(Atomicity) 原子性:

**事务中的操作要么全部成功,要么全部失败**

- 要想保证原子性,就要实现在事务失败的时候,对事务所做的操作进行回滚

### D(Durability) 持久性

**事务一旦成功(被提交),其对数据库的修改会永久保存在数据库中**

- 持久性和原子性可以通过redo log来保证

	- redo log(重做日志),用于保证原子性和一致性,其由两个部分组成,一个是在内存中保存的缓存部分(redo log buffer),一个是保存在磁盘中的文件(redo log file)

		- 在每次事务中修改的时候,都会先将数据从磁盘读入内存,然后在内存中进行数据的修改,并生成一条redo log 的记录插入到redo log buffer 中,等到事务真正提交了,就会将该事务产生的redo log buffer 刷新到磁盘中,并将修改后的数据也从内存刷新到硬盘
		- 为了让两份日志的逻辑一致,每一次事务提交都要进行两阶段提交,第一个阶段是写入redo log并处于prepare阶段,在这个阶段中写入binlog,然后提交事务,如果中间有一步失败了,会处于prepare阶段中,事务回滚时也会将文件记录抹去
		- 当数据库发生宕机时,可以通过redo log来恢复数据

### C(Consistency) 一致性

**数据库在事务执行之前状态是一致的,提交或者回滚后也要保持其一致**

- Undo log(回滚日志):主要用于事务的回滚和MVCC机制实现

	- Undolog是InnoDB在引擎层实现的,所以MyISAM没有Undolog,但是Mysql在服务层也实现了一个归档日志binlog
	- 回滚日志会记录着我们对数据库进行的修改,当该事务失败的时候,就会读取undo log中的记录,并进行其逆操作来使数据库记录恢复成事务没有发生之前
	- 对于select语句,不需要进行回滚,对于update 语句将会将左值和右值进行逻辑上的互换,然后执行逆update,而对于insert语句,则进行delete

### I(Isolation) 隔离性:

**规定多个并行事务之间如何读取数据**

## 锁算法

### Record Lock

- 单行记录上的锁

### Gap Lock

- 间隙锁,锁定一个范围但是不包含记录本身

### Next-key Lock

- 锁定一个范围并包含记录本身

![](http://imageblog.boyn.top/202002031207_673.png)

## 数据库中的锁

着重地说InnoDB与MyISAM的锁:对于MyISAM来说,锁只有表锁,对于并发量的支持不太好,而InnoDB的锁粒度为行级,对于并发量的支持比MyISAM要高,它提供非锁定的一致性锁和行级锁

### 行锁与表锁

顾名思义,行锁指的是对某行或某范围内数据的锁定,而表锁是对整张表的锁定

在效率上,表锁的加锁效率大于行锁,但是表锁的并发性能远低于行锁

### 锁的类型

- 共享锁(shared - s)

	- 允许事务读取一行的数据
- 排他锁(exclusion - x)

	- 允许事务更新或删除一行数据
- 锁的共容性

	- X

		- 不兼容
		- 不兼容

	- S

		- 不兼容
		- 兼容
- 自增锁:自增锁是应对`auto_increment`情况

## MVCC机制

### 一致性非锁定读

- 一致性非锁定读是指数据库通过MVCC(多版本并发控制)机制来读取当前时间时数据库中每一行的数据,通俗来说,假设该行有其他事务正在执行删除或者更新但是还未提交,这个时候本事务读取到的数据是该行之前的一个快照数据

说白了,就是每一个连接看到的只是数据库的一个快照,写连接在写操作完成之前,对其他连接不可见(不可重读隔离级别)

### 实现原理

在每个表中,都会有两隐藏列,分别是 `DATA_TRX_ID`、`DATA_ROLL_PTR` 

DATA_TRX_ID记录着这条记录的事务ID

DATA_ROLL_PTR记录着指向上一个版本的指针,之前的版本的数据会放在undo log里面通过链表的形式来组织

而当有`update`,`insert`,`delete`等操作产生时,就会先复制一个新行,将旧行放入undo log中,并设置DATA_TRX_ID为新行的值,而DATA_ROLL_PTR就指向undo log中上一个记录的事务ID

### 一致性读

在`Read Uncomiitted`隔离等级下,直接读最新记录的版本就可以了,`Serial`级别是通过互斥锁来锁数据,不会用到MVCC

所以,在`Read Committed`和`Repeatable Read`这两个隔离等级下,才会用到MVCC,这里InnoDB创建了一个ReadView的概念

### RR下的RV

在RR下,每个事务第一次执行select的时候,会将所有活跃事务拷贝到一个列表中,对该事务可见,生成ReadView,随后就不会再改变

### RC下的RV

在RC下,每次select都会更新活跃事务的列表

### ReadView

ReadView中,最重要的两个值是最小的事务值和最大的事务值,对于事务值来说,是按照事务开始的先后顺序进行分配的,那么对于当前事务的可见性是这样的

- 如果访问版本的事务号小于RV中的最小值,说明已经提交,可以访问
- 如果访问版本的事务号大于RV中的最大值,说明不可访问
- 如果事务号在范围内,则要判断是否在RV内,如果在,则不可访问,如果不在,则可以访问