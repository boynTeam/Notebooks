我们在前面说了很多关于分布式的内容,其中一项很重要的内容就称为一致性,一致性的内容非常广阔,而且不仅仅是分布式,我们在数据库的事务中,也涉及到了一致性的内容.那么,到底什么是一致性呢?

我们就要从程序运行的正确性说起了.

# 正确性

在程序运行中,处处都是正确性的体现.比如`i= 0;i++;`的结果是1.更广泛地来说,我们对系统所做的所有操作都是一种状态的转移,一个系统由*状态*和*状态转移操作*构成.

当我们运行一个程序的时候,写入了一个值`a`,那么在下次读取的时候,也理应读取到`a`,我们将这种程序称为单一寄存器程序(并不是只用一个寄存器,而是表现得像).在我们刚开始学习编程的时候,我们就已经将这样的行为模式当作是系统的正确性表达了.但是,在不同的系统环境下,可以并不一定会像我们预想的一样表达方式,在这里,我们就称为这个系统与我们预想的有出入,是**不正确**的.

其实,对一个系统来说,其正确定的定义如下:给定一些涉及操作与状态的规则,并且随着操作的演进,系统将会一直遵循这些规则,我们将这样的规则称为**一致性模型**.

# 并行下的一致性模型

我们在编程的时候,如果涉及到了共享内存(可以是多线程,多进程,甚至是消息队列等),那么,我们上面所理解的一致性,就会发生失效,一个很简单的例子,我们在学习java多线程知识的时候,发现如果一个变量被多个线程同时修改,那么修改的结果在大多数时候不会像我们预测的一样,这个原因在于变量会被线程所缓存.

同样地,在多CPU,网络复杂的环境下,数据的运算,数据的传输都是需要一定的时间并且会有一定的失败概率.所以在并行环境(分布式也是一种并行环境)下,我们就需要修改我们的一致性模型,以达到更好的匹配效果.

从字面意义上来说，『一致性』关注的是分布式系统中不同实体之间数据或者状态的一致程度；而从实际的角度来看，『一致性』其实反映了系统对 client 提供的服务所表现出的特征

# 常见的一致性模型

在计算机科学领域中,为了适应不同的环境,提出了各种一致性模型的概念,下面是一些常见的一致性模型以及他们之间的关系,箭头表示*实现*的关系.

![](http://imageblog.boyn.top/202003021530_672.png)

在我们之前说过的CAP理论中,一致性和可用性是一种权衡,在我们看到的一致性模型中,其颜色表示了不同的一致性和可用性保证:

- 粉色: 当网络发生错误的时候,系统不可用.为了安全,某些节点或者全部节点需要暂停他们的操作
- 黄色: 只要在出现错误的时候,客户端只与同一个的节点沟通而不是切换节点,那么其在非故障的节点中保证可用.
- 蓝色: 即使网络出现故障,也可以保证节点可用.

# 分布式系统的一致性模型

在上面的图中,我们看到了各种一致性模型的图片,但是在分布式系统中,并不是所有一致性模型都会被使用,最常见的是

- #### 线性一致性 (Linearizability)

- #### 顺序一致性 (Sequential consistency)

- #### 因果一致性(Causal consistency)

- #### 最终一致性(Eventual consistency)

## 线性一致性

线性一致性又被称为强一致性或者原子一致性.我们在这篇文章中并不打算使用定义来进行描述.相反地,我们以一个分布式数据库的例子来实际说明线性一致性的含义.

如果我们将整个分布式数据库作为一个整体来看,那么对于某一个client,它对数据库的读写操作就要满足线性一致性了.

### 单个Client

在只有单个Client访问数据库的情况下,对于数据库的单个读写操作需要满足线性一致性,假设有这样的情况

![](http://imageblog.boyn.top/202003021747_786.png)

对于我们视角来说,得到的结果**期望**是最近写入的值.

所以,线性一致性其实刻画的是我们对于分布式系统的自然期望:

- 每一个读操作都能返回基于单一的实际时间最近的写操作的值
- 对任何client表现是一致的.

上面说的基于单一实际时间看起来不是那么好理解,我们以一个实际的例子来看一下

![](http://imageblog.boyn.top/202003021913_472.png)

在这次,有两个Client,并且他们的读写操作发生了重叠.

由于线性一致性要保证在多个客户端下,表现会像是串行执行的.

所以我们的读取预期,就是P1写入2在前,P2写入3在后,P1,P2都会读到3这个值