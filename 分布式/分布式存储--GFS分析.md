本文根据MIT 6.824 分布式系统 的 Lecture3: GFS 整理得出



在我们要知道什么是分布式存储,以及什么是GFS之前,我们首先需要了解一点关于分布式系统的知识

# 分布式系统设计的难点

我们首先要明确,对于一个分布式系统来说,会有成百上千台服务器在同时运行着.分布式的目的是为了在机器性能垂直拓展(加内存,换好的CPU)有边界递减效应的情况下,使用水平拓展(多台机器同时运行)的方式来增加系统的性能.

但是,我们要知道,如果用了多台机器,那么出错率也会上升.

在分布式系统中,我们为了提升性能,通常会对数据进行分片,而且为了错误容忍性,还要进行分区复制

实现了上面的特性,就会出现一致性的问题,根据CAP定理,我们想要强一致性,就会降低可用性,从而降低性能,而如果要提高性能,就要对一致性做出牺牲.

我们在下面将会看看GFS是如何做出权衡的.

# 什么是强一致性

在[一致性模型](http://boyn.top/post/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/)中,我们提到了强一致性,在此我们需要再次对其进行说明.所有的一致性模型,都是以客户端为视角,对服务端的读写操作所作出的预期,在强一致性下,无论面对的服务端是一个服务器或者多个服务器,其预期都是*读操作会读取到实际时间上最近一个写入的值*.

其结构如图所示

![](http://imageblog.boyn.top/202003022333_721.png)

我们将结合下图来解释强一致性模型中,预期读到值的规则

![](http://imageblog.boyn.top/202003022336_96.png)

在这张图中,`Client 1`与`Client 2`同时写入x的值为1,2,而`Client3`和`Client4`在稍后对这个值进行读操作.那么,其行为取决于服务端如何处理同时写入的值,如果先处理1,再处理2,那么读到的内容就是2,反之亦然.这就反应了我们刚刚所说的会读到以实际时间为标准最近的值. 

# GFS的特点 

GFS(Google File System)是谷歌内部使用的大文件分布式存储系统,它的特点在于它可以将大文件自动分割成小块进行存储,容灾性,存储量大,读取快等特点.它是一个非对外公开的软件,它仅在谷歌内部的数据中心使用,其大文件存储的特性是根据谷歌自身的业务结构(爬虫,视频等大文件为主)量身定做的.

GFS其本身并没有非常新颖的知识,其所用到的分布式架构已经在多年前被学术界提出来了,但是之所以GFS是分布式存储的一个里程碑,在于它是第一个有超大型工程实践经验的分布式存储系统. 

# GFS的架构

![](http://imageblog.boyn.top/202003041444_41.png)

如图,GFS部署在多台服务器上, 但是仅有**一个**Master节点,其他的都是ChunkServer节点.

## Master节点

Master最重要的工作有两个,一个是维护客户端与Master的通信,以及Master与Chunk节点的通信,还有另一个是维护映射表,关于从文件名映射到数据实际存储的地方.

实际上,Master本身不存储数据,它只会存储Chunk节点的位置(IP地址,端口等)以及文件名对应的数据存储在哪些Chunk服务器中.

而Master节点的主要内容如下

![](http://imageblog.boyn.top/202003041504_739.png)

它会维护两张表,一个是文件名对应的ChunkHandlers数组,而每一个ChunkHanlder中都包含了这个文件的版本,这个文件的第一个服务器,这个文件分布在哪些服务器中以及其最后的更新时间.这两张表中许多信息为了保证速度是直接放在了RAM中,为了可用性的保证,还会进行log日志和checkpoint的持久化

![](http://imageblog.boyn.top/20200304161247.png)

# GFS的读写流程

## 读取信息

1. 客户端向Master节点传入文件名与offset
2. Master返回ChunkHandler,包含所有包含文件的服务器信息
3. 客户端会缓存这个结果,以便再次读取
4. 客户端会与其中一个ChunkServer通信,试图取得文件
5. ChunkServer通过网络返回文件内容

## 写入信息

1. 客户端向Master询问包含该文件最新版本的ChunkServer,包括Primary节点和其余的Replica,如果没有Primary的话,Master就会向某个Replica提出将其临时作为Primary
2. Master将Primary和Secondary回应给客户端,客户端将这些进行缓存,如果Primary和Replica无法通信时,会再次向Master请求,其余情况则使用这个缓存的数据
3. 客户端向所有的Replica推送这段数据,这段数据在没有被确认之前,会存放在所有ChunkServer的LRU缓存中,而不会持久化到硬盘
4. 当所有的Replica收到了这段数据之后,客户端会发送一个写请求给Primary,Primary将按顺序将可能来自多个客户端的写请求进行处理,将这些数据持久化
5. Primary将这个写请求发送到每一个Replica中,以相同的方式将其持久化
6. Replica向Primary发送ACK信息
7. Primary向客户端回报,当然有可能会出现失败的情况,这样客户端都会在3-7之间进行几次重试

![](http://imageblog.boyn.top/20200304161210.png?imageView2/0/q/75|watermark/2/text/Ym95bi50b3A=/font/5b6u6L2v6ZuF6buR/fontsize/600/fill/IzAwMDAwMA==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim)

