# 分布式系统的挑战

分布式系统可以拓展我们的数据服务,当一台电脑的性能不足以支撑服务或者担心一台电脑没有备份容易丢失数据时,可以使用分布式的系统来进行拓展,一般会有两种手段:

1. 数据分区处理:将数据取某个哈希值,然后将其分区,让不同的机器来对数据进行处理
2. 数据镜像处理:让所有的服务器都拥有相同的数据,提供一样的服务

相比第一点,第二点可以有效解决单机丢失数据的问题,所以大多数分布式系统都是将数据做冗余镜像处理来保证可用性的,但是根据CAP理论,我们想要服务器的高可用性,那么就要牺牲一定的一致性性能了,具体来说,我们如果想要每个服务器的数据都是一样的,那么为了保持数据的一致,我们需要通过网络来传输数据,需要时间,从而降低了服务的一致性.



# 分布式事务

加入了更多的机器后,我们的数据服务就会变得复杂起来,尤其是跨机器的数据一致性要如何保证.比如说,我们要使用A账号给B账号打钱,在同一台机器中,可以直接使用事务来解决,但是如果跨机器的时候,问题就来了.

由于我们每台机器都会有A,B账号的副本,要如何保证A给B汇钱成功后,备份都会进行更新呢,假设A同时给B,C汇钱,并且这个操作发生在两个服务器上面,要如何保证写一致性,保证数据不冲突呢?

# 数据的一致性模型

一般来说,数据一致性简单地可以分为3种类型

- 弱一致性:当我们写入了一个新值的时候,读操作在副本服务器种可能可以读出来,也可能读不出来,比如某些分布式缓存系统,没有必要保证所有的服务器上面的缓存是强烈一致的
- 最终一致性:当我们写入了一个新值之后,立刻读副本服务器有可能是读不出来的,但是可以保证在某个**时间窗口**之后,最终可以读得出来,比如MongoDB分布式数据库
- 强一致性:新的数据一旦写入,立刻读取副本服务器肯定可以读得出来

从数据的一致性模型来看,弱一致性和最终一致性通常是异步冗余的,而强一致性一般是同步冗余的.异步意味着性能更好,但是操作,逻辑更复杂,同步意味着性能下降,但是操作简单

# 分布式事务模型

## Master-Slave 主从模型

对于这种模型,一般来说在启动时要选举出一个Master节点,并且Slave节点都是Master节点的备份,其读写逻辑是这样的

- 读写都由Master负责
- 写的请求先写到Master中,然后由Master同步到Slave上

一般来说,这个同步的操作有很多种,可以是Master主动push,也可以是Slave周期性地对Master节点pull,所以这个模型一般是实现最终一致性

## Master-Master 多主模型

也称Multi-master模型,指的是一个系统中可以有多个主节点,每一个主节点都可以提供读写服务,数据间的同步一般是通过Master间异步完成,所以一般是实现的最终一致性.好处在于Master节点出现了问题的话不会使服务停止.但是如果有多个Master对同一段数据进行修改,那么问题就会出现了--对数据间的冲突会合并,对于部分开源产品来说,这个冲突的合并不预先指定逻辑,而是将冲突抛给用户,让用户自己解决.

