

在Unix下,有五种可用的IO模型:

- 阻塞式IO
- 非阻塞式IO
- IO复用(select,poll)
- 信号驱动IO
- 异步IO

除了信号驱动不常用之外,前面三种都是同步的IO,最后一种是全异步IO

IO调用过程有两个步骤

1. 等待数据准备
2. 将数据从内核拷贝到进程空间

对于前面三个,其阶段1的表现不同,但是阶段2都是阻塞的,称为同步IO,但是最后一个IO模型的第二阶段不是阻塞的,称为非同步,即异步

# 阻塞式IO

在IO编程中,最流行,也是最简单的IO模型就是阻塞式的IO模型,默认情况下,所有的套接字读取和写入都是阻塞的

![](http://imageblog.boyn.top/202001291645_87.png)

在调用系统的读取函数时,会陷入内核并将该进程挂起,直到数据报准备好了之后,才会将数据报从系统的缓存复制到进程的内存空间中,并将阻塞函数返回,并使进程的状态转换为就绪

# 非阻塞IO

![](http://imageblog.boyn.top/202001291648_496.png)

对于非阻塞式IO,它的非阻塞地方在于我们调用recv函数的时候,他会立刻返回是否准备好的结果(如果没准备好就会返回错误),而不会阻塞,当准备好了之后,才会返回数据.但是其系统内核从数据报准备好到将其复制到进程空间中的过程仍然是阻塞的,所以还是同步IO.

在这种模型中,我们的进程在数据报还没有准备好之前不会阻塞,所以可以做其他事情,但是我们需要轮询来确认数据是否准备好,会造成性能损失

# IO复用

IO多路复用在系统底层是通过select或者poll,epoll来进行的

IO复用的好处在于可以同时对多个IO操作进行监听和操作

![](http://imageblog.boyn.top/202001291844_443.png)

我们在调用select时,可以等待多个socket,同时对多个IO端口进行监听,然后调用select后,会阻塞线程,当任一端口有数据到达的时候,select函数就会返回然后进程再使用recvfrom进行数据的拷贝和后续的处理.

select,poll与epoll虽然都是IO复用模型下的函数,但是其调用过程略有不同,其中epoll是对select,poll的改进

epoll是一个函数簇,包含create,ctl,wait三个函数,作用分别是创建句柄,注册监听事件和等待事件产生,并将IO连接的对象用红黑树进行管理起来,当有准备好的IO连接后,将其放入事件链表中,执行wait时返回该链表..而ctl可以单独操作某个epoll对象,将socket单独添加或删除.

对比起select在每次调用时,都要将全部socket列表从内核和用户态之间来回copy高效得多

# 异步IO

在异步IO模型中,一切操作在进程看来都不需要阻塞

![](http://imageblog.boyn.top/202001292042_958.png)

在异步IO中,由进程调用aio_read并立刻返回,然后当数据报完全准备好并复制到进程空间后,会向进程发送信号,根据这个信号,进程处理这个数据包