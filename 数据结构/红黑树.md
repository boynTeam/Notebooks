 红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。 

 红黑树，作为一棵二叉查找树，满足二叉查找树的一般性质。下面，来了解下 二叉查找树的一般性质。 

## 二叉查找树

二叉查找树也称二叉搜索树,它具有以下的几个特点:

- 如果任意结点左子树不为空,那么左子树所有的结点都小于该结点
- 如果任意结点右子树不为空,那么右子树所有结点都大于该结点
- 任意结点的左右子树也是二叉查找树
- 所有结点的键值都不相等

上面的性质其实与二叉查找的步骤十分相似,所以它的查找效率跟二叉查找是一样的为`O(log(n))`,但是二叉查找树的性能跟插入的顺序有很大的关系,假如插入的是一个有序数组,那么就会退化成一个链表,查找复杂度变成`O(n)`

所以我们要寻找一个办法,使得查找树的高度**尽量**保持在log(n),这就引出了我们下面要说的

## 红黑树

红黑树本质上也是一颗二叉查找树,但是在普通查找树的基础上,增加了着色和相关的性质,使得红黑树相对比较平衡,保证了查找,插入,删除的时间复杂度最坏为`O(log(n))`.它的性质如下:

1. 每个节点不是红的就是黑的
2. 根结点是黑的
3. 每个叶结点是黑的
4. 如果一个结点是红的,那么其儿子都是黑的
5. 查找时黑色平衡(从顶到叶子结点经过黑色子结点相同)

![](http://imageblog.boyn.top/201912281659_7.png)

## 旋转

要想红黑树实现这些性质,我们首先要知道什么是红黑树的旋转.旋转一般有两种,左旋和右旋

### 左旋

![](http://imageblog.boyn.top/201912281727_359.png)

如图所示,我们将pivot这个结点进行左旋,并将其左子树和右子树的结点做相应调整

```a

LeftRoate(T, x)
y ← x.right				       //定义y：y是x的右孩子
x.right ← y.left	            //y的左孩子成为x的右孩子
if y.left ≠ T.nil
    y.left.p ← x	
y.p ← x.p				       //x的父结点成为y的父结点
if x.p = T.nil
	then T.root ← y
else if x = x.p.left
	then x.p.left ← y
else x.p.right ← y 
y.left ← x                       //x作为y的左孩子
x.p ← y
```

### 右旋

![](http://imageblog.boyn.top/201912281729_769.png)

与左旋是类似的

## 红黑树的插入

红黑树的插入,相当于是在二叉查找树的插入基础上面,为了重新恢复平衡,而做了插入修复的操作.所以可以将红黑树的插入分为两个部分,分别是插入和插入修复

插入的伪代码如下所示

```
RB-INSERT(T, z)
y ← nil
x ← T.root
while x ≠ T.nil
	do y ← x
	if z.key < x.key
		then x ← x.left
	else x ← x.right
z.p ← y
if y == nil[T]
	then T.root ← z
else if z.key < y.key
	then y.left ← z
else y.right ← z
z.left ← T.nil
z.right ← T.nil
z.color ← RED
RB-INSERT-FIXUP(T, z)
```

这段代码的过程简要描述为,我们要插入一个结点的时候,不停地跟结点比较,如果这个结点的`key`大于我们要插入结点的`key`,就与该结点的左节点进行比较,反之与右结点比较,直到叶子结点为止,然后创建一个新的结点并插入到最后一个比较的结点的子节点上,并将其两个子节点赋值为空,以及将其涂成红色,然后进行插入修复

