---
title: 面试题46 把数字翻译成字符串
date: 2019-11-07 09:19:57
tags:
	- 算法
	- 刷题
	- 剑指Offer
    - 数字
    - 动态规划
categories:
	- 算法
	- 刷题
---

## 问题描述

给定一个数字，我们按照如下规则把它翻译为字符串：

0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。

一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。

请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。

<!--more-->

## 思路

这道题是一个典型的动态规划问题,可以采用自底向下的方法,从最后一个数字开始进行翻译.

建立一个dp数组,长度为字符串的长度,其表示翻译到这个字符串时,从这个字符串开始翻译有多少种翻译方法,也就是有多少个路径

其基本步骤是,我们在遇到一个数字的时候,先判断是不是最后一个,如果是最后一个,那么只有一种方法,则设置`dp[length] = 1` ,如果不是最后一个的话,那么我们就会面临两种选择,从这个字符串开始翻译,有的只能翻译自身,有的能够翻译自身与下一个字符组成的数,这取决于这两个数加起来是否大于等于10小于26,也就是是否在所能够翻译的字母范围内,如果是的话,那么就多了一种选择.

假设我们有字符串"12258",如果从右向左,可以看到,当翻译8时,只能翻译自身,所以dp[4] = 1;当翻译5时,也只能翻译自身,所以dp[3] = dp[4] 当翻译2时,可以翻译为25 或者翻译为2 于是有两种选择, dp[2] = dp[3] + dp[4],可以理解成翻译这个字符串后,如果翻译的是2,那么跳到下一个是5,如果翻译的是25,跳到下一个是8,所以翻译的结果数量就是翻译5,8位置时数量的加和.

## 编码

```java
class Solution {
    public int getTranslationCount(String s) {
        char[] array = s.toCharArray();
        return num(array,0);
    }
    
    private int num(char[] s,int begin){
        int[] counts = new int[s.length];
        counts[s.length-1] = 1;
        for(int i = s.length - 2;i>=0;i--){
            int count = counts[i+1];
            int digit1 = s[i] - '0';
            int digit2 = s[i+1] - '0';
            if(digit1*10 + digit2 < 26 && digit1*10 + digit2 >=10){
                if(i<s.length-2){
                    count += counts[i+2];
                }else {
                    count += 1;
                }
            }
            counts[i] = count;
        }
        return counts[0];
    }
}
```

## 做题记录



| 状态 | 日期          | 评价                      |
| ---- | ------------- | ------------------------- |
| 👍    | 2019年11月7日 | 一道经典的DP题目,值得多看 |