---
title: 面试题14 剪绳子
date: 2019-10-19 14:19:57
tags:
	- 算法
	- 刷题
	- 剑指Offer
	- 动态规划
categories:
	- 算法
	- 刷题
---

## 问题描述

 给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 

<!--more-->

## 动态规划思路

这是一个经典的动态规划问题,在算法导论一书中,这个问题出现在了动态规划章节的第一个题目中.在这篇文章中,我们首先会用经典的动态规划做,其时间复杂度为O(n²),空间复杂度为O(n).然后我们会用一个贪婪算法的思路来做,其时间和空间复杂度都是O(1)

我们先来看一段对动态规划的定义

![](http://imageblog.boyn.top/201910191505_617.png)

在这个题中,我们如果要应用动态规划的话,首先我们要知道什么是大问题,什么是小问题.比如绳子的长度为8,那么,如果我们要知道绳子剪成m段的长度的最大乘积,就要先知道长度为7,6,5,4,3,2,1的绳子剪成m段的长度的最大乘积是什么.换句话来说,我们要求长度为8的结果时,可以先求其子长度的结果.

假设我们的第一刀剪在了i的位置,那么其乘积就是i*n-i,我们如果要求n的最优解,那么就要知道i的最优解和n-i的最优解.而我们为了避免重复求解子问题,动态规划通常都是自下而上地进行的.

![](http://imageblog.boyn.top/201910191516_429.png)

在这道题中,我们每一步就会有n-1种选择,会剪在1,2,...,n-1的地方,这需要我们都遍历一遍

## 动态规划编码

```java
public class Solution {
    public int cutRope(int target) {
        if(target==0){
            return 0;
        }
        if(target==1){
            return 0;
        }
        if(target==2){
            return 1;
        }
        if(target==3){
            return 2;
        }
        int[] len = new int[target+1];
        len[0] = 0;
        len[1] = 1;
        len[2] = 2;
        len[3] = 3;
        for(int i = 4;i<=target;i++){
            int max = 0;
            for(int j = 1;j<=i/2;j++){
                int product = len[j]*len[i-j];
                if(product>max) max = product;
            }
            len[i] = max;
        }
        return len[target];
    }
}
```

根据题目的定义,要把绳子剪成m段,m>1,这说明当长度小于2后,没有办法剪,所以结果是0,当为2时,剪成1*1.

如果长度大于3,那么就改用动规来做了,跟上面思路说的步骤差不多.

## 贪心算法思路

![](http://imageblog.boyn.top/201910191532_827.png)

一般来说,贪心算法能够取得比动态规划更好的性能,但是证明其正确性比较费工夫

![](http://imageblog.boyn.top/201910191543_705.png)

## 做题记录

| 状态 | 日期           | 评价               |
| ---- | -------------- | ------------------ |
| 💪    | 2019年10月19日 | 对动态规划不太熟练 |