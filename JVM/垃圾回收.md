# 什么是垃圾回收

垃圾回收是GC(Garbage Collection),JVM中用于自动内存管理的手段.

在C++中,没有垃圾回收的机制,所以我们要手动来释放内存,而在Java中,这个事情则是交给JVM来进行自动管理,我们在创建对象时使用new,然后不需要手动释放对象,JVM会在适当的时候为我们清理对象,这个行为称为垃圾回收

# 如何确定某个对象是垃圾

在垃圾回收的机制中,确定一个对象是否为垃圾的方法有两种,第一种是引用计数法,第二种是可达性分析

## 引用计数法

为每一个对象添加一个引用计数器,当有其他对象对其进行引用的时候,将计数器加一,而如果该引用被赋为其他值,则将其-1,而当计数器为0的时候,说明该对象已经死亡,可以回收

这个方法实现起来很繁琐,因为要将所有的更新操作都考虑到,并且还要为每一个对象添加一个计数器,并且还有一个缺陷是其无法解决循环引用的问题

## 可达性分析

目前JVM主要使用的GC使用的是可达性算法,这个算法将一系列GC Roots作为默认存活对象集合,然后从该集合的每一个元素出发,寻找所有可以被探索到的对象并为其做上标记,添加到集合中,那么如果不在集合中的对象,就是不可达对象,说明已经死亡,所以可以被清除.

一般来说,以下的这些对象都可以作为GC Root

1. 方法栈帧中的局部变量
2. 已加载的类的静态变量
3. JNI处理器
4. Java正在运行的线程对象

可达性分析比引用计数法要好得多,可以解决循环引用的问题了.但是在多线程环境下,有可能会因为不同的对象产生而产生分析不准的情况,有可能出现误报或者漏报,而严重地可能造成虚拟机崩溃

## Stop the World

所以为了在多线程下的可达性分析准确率,需要在进行分析的时候停止所有非垃圾回收线程的运行.该行为被称为Stop the World.

这个机制是通过安全点来进行的,当JVM收到STW请求的时候,它会等待所有线程到达安全点,再开始分析,安全点并不是为了让线程停止,而是为了找到一个稳定的状态使JVM的堆栈不会发生变化,这么一来就可以安全地执行可达性分析了.

# 垃圾回收的方式

主流的垃圾回收有三种方式,清除,清除并整理,复制

## 清除

将死亡对象的内存标记为空闲内存,记录在一个列表中,下一次要创建对象时,从这个列表寻找一个空间可以容纳此对象的,将其划分给新的对象

清除的原理十分简单,实现也不难,但是缺点在于多次清除后,会产生很多内存碎片,从而使得大对象的创建比较困难

并且其分配效率比较低,如果是连续内存,只需要使用指针加法来做分配就可以了,而如果是碎片内存,还需要去遍历列表寻找可以放得下该对象的内存空间

## 清除并整理

也称为压缩,将存活的对象一个个的并到开头,从而使空闲空间都放在了后面,留下了一段连续的内存空间

这个方法的好处是解决了空间碎片的问题,但是缺点是压缩算法的性能开销比较大

## 复制

复制算法将内存区域分为两个部分,通常内存分配都在其中的一个区域中,进行GC的时候,将活跃的对象放入另外一个区域中,然后转换活跃的区域.

优点是同样可以解决内存碎片化的问题,但是缺点在于一半的空间无法被利用

# 垃圾的分代回收

通过分析,JVM研究人员发现大部分的对象只会存活很短的时间,而只有小部分的对象才会长久存在,这也就是28定律的体现

这个发现造就了JVM的分代回收思想,简单来说就是将堆分为两代,年轻代与老年代,每次GC的时候,将存活的对象的存活时间增加,到了一定的次数后,将其放入老年代的空间中.

这样做的好处是,可以为不同代使用不同的垃圾回收算法,对于年轻代而言,大部分的Java对象都只能存活一小段时间,所以可以频繁地采用耗时比较短的垃圾回收算法,让大部分垃圾能够在新生代被回收,称为Minor GC.

而对于老年代,一般是在堆空间不足的时候,才会触发对其的垃圾回收,通常这个时候JVM会对全堆都做一次扫描.称为Full GC

分代的空间划分如下

![](http://imageblog.boyn.top/202001312146_520.png)

Eden:from:to 默认是8:1:1

在MinorGC中,Eden区和活跃Survivors区中的存活对象会被复制到空Survivors区中,当Survivors中的对象被复制超过一定的次数后,就被转入老年代.

# 垃圾回收器

针对新生代的垃圾回收器:Serial，Parallel Scavenge 和 Parallel New,他们都是使用的标记-复制算法.其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用

针对老年代的垃圾回收器: Serial Old 和 Parallel Old，以及 CMS  

Serial Old 和 Parallel Old 都是标记 - 压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。

 G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。

G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。  

![](http://imageblog.boyn.top/202002021727_154.png)

## 新生代收集器

### Serial

Serial是新生代的收集器,它是采用复制算法的,是一个单线程的收集器,在进行收集的时候,会停止所有工作线程

![](http://imageblog.boyn.top/202002021742_868.png)

与他对应的是Serial Old,同样是单线程的.

Serial由于其简单,没有线程切换开销的特性,所以是Java客户端的默认新生代收集器

### ParNew

ParNew可以看作是Serial的多线程版本,其原理与Serial大致相同

![](http://imageblog.boyn.top/202002021744_421.png)

它与Serial在原理上并无太大的不同,它是服务器的首选新生代收集器

它在单线程环境下表现比Serial要糟糕,但是在多个CPU下表现会好得多,默认GC线程数是CPU的数量

### Parallel Scavenge

与 ParNew 一样是多线程收集器。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

## 老年代收集器

### Serial Old

它是一个单线程的收集器,使用标记整理算法进行垃圾回收

### Parallel Old

Parallel Scavenge的老年代版本,使用了多线程+标记整理算法

同样,它也是以吞吐量为优先,

### CMS收集器

CMS是以获取最短STW时间为目标的老年代收集器

基于标记-清除算法实现

CMS的清除分为以下几步

1. 寻找需要清除的对象,即从GCRoots开始标记能够直接关联到的对象,这个用时很短,且仅在这个时候才需要Stop The World
2. 进行GC Roots的遍历标记,标记所有能够被关联到的对象
3. 重新标记,修正因并发标记期间用户继续运作而产生变化的那一部分记录,这里也要STW
4. 并发清除 

![](http://imageblog.boyn.top/202002021938_605.png)

 CMS是一款优秀的收集器，它的主要**优点**在名字上已经体现出来了：**并发收集**、**低停顿**，因此CMS收集器也被称为**并发低停顿收集器（Concurrent Low Pause Collector）**。 

但是 CMS 收集器远达不到完美的程度，主要有以下三个缺点

- CMS 收集器对 CPU 资源非常敏感  原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%,显然是不可接受的
- CMS 无法处理浮动垃圾（Floating Garbage）,可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 **Concurrent Mode Failure** 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。
- CMS 采用的是标记清除法，上文我们已经提到这种方法会产生大量的内存碎片，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。

## G1收集器

G1收集器是面向服务端的垃圾回收器,它模糊了老年代和年轻代的概念,并可以替换掉CMS回收器

它的特点如下

1. G1可以充分利用多CPU的优势,使得可以使用多个CPU来缩短STW的时间
2. G1不需要其他收集器就可以管理整个GC堆
3. 从整体来看,它是使用标记-整理算法的回收器,而局部上是利用复制算法实现的.
4. STW时间可预测,G1收集器可以建立一个可预测的停顿时间模型

 而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它**将整个Java堆划分为多个大小相等的独立区域（Region）**，虽然还保留新生代和老年代的概念，但**新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合**。 

 G1收集器之所以能建立可预测的停顿时间模型，是因为它可以**有计划地避免在整个Java堆中进行全区域的垃圾收集**。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），**在后台维护一个优先列表**，每次根据允许的收集时间，**优先回收价值最大的Region（这也就是Garbage-First名称的来由）**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。 

 为了避免全堆扫描的发生，虚拟机**为G1中每个Region维护了一个与之对应的Remembered Set**。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable**把相关引用信息记录到被引用对象所属的Region的Remembered Set之中**。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。 

G1收集器大致上可以分为以下流程:

- **初始标记（Initial Marking）** 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改**TAMS（Nest Top Mark Start）**的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要**停顿线程**，但耗时很短。

- **并发标记（Concurrent Marking）** 从GC Root 开始对堆中对象进行**可达性分析**，找到存活对象，此阶段耗时较长，但**可与用户程序并发执行**。

- **最终标记（Final Marking）** 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在**线程的Remembered Set Logs**里面，最终标记阶段需要**把Remembered Set Logs的数据合并到Remembered Set中**，这阶段需要**停顿线程**，但是**可并行执行**。

- **筛选回收（Live Data Counting and Evacuation）** 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

  ![](http://imageblog.boyn.top/202002021958_574.png)