# TCP首部字段

![](http://imageblog.boyn.top/202002011349_820.png)

- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

# 三次握手

三次握手是指在建立一个TCP连接的时候,需要客户端,服务端总共有3次通信,来确定连接的信息.即

- 确认双方收发能力是否正常
- 确认双方的序列号和确认号
- 确认滑动窗口的数值

![](http://imageblog.boyn.top/202002011339_626.png)

## 状态转移

1. 在刚开始,客户端处于`CLOSED`状态,服务端处于`Listen`状态.客户端主动向服务端发起连接请求
2. 第一次握手:客户端发送一个SYN报文,指明序列号为一个随机值(在BSD中是随时间增加并循环的值),然后将状态转变为`SYN_SEND`状态
3. 第二次握手:服务端收到客户端的SYN报文后,以一个随机值为序列号,以客户端的ISN+1作为确认号(虽然前面的包并不携带数据,但是会占用一个序号),发送回去一个SYNACK报文,此时服务端处于`SYN_RECV`状态
4. 第三次握手:客户端收到了服务端的SYNACK报文后,以SYNACK报文的确认号作为新报文的序列号,以SYNACK报文的序列号+1作为确认号,发送给服务端一个ACK报文,客户端转为`ESTABLISHED`状态,服务端收到报文后,也会处于`ESTABLISHED`状态,握手完成

## 丢包问题

如果在第三次握手中丢包了,那么客户端此时为处于`ESTABLISHED`状态,但是服务端仍在`SYN_RECV`状态,这样是不能正常收发报文的.对于服务端来说,如果长久没有收到ACK报文,那么会选择重发SYNACK报文,如果客户端再次发送ACK报文收到了,还是可以正常连接的.然而,如果超过了一定的时间,服务端会给客户端发送RTS报文表示超时关闭.

## 为什么要三次握手

1. 需要三次握手来确定Socket,序列号和窗口大小

如果是使用两次握手,无法消除历史错误报文造成的空连接,会浪费双方的资源.

> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。
>
> 后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

## 什么是半连接队列

服务器在第一次收到客户端的SYN之后,就会处于SYN_RECV的状态,但是此时双方还没有完全建立连接,这个时候服务器会先将这个状态下的连接放在一个队列中,称之为半连接队列,如果成功建立连接之后,就会将这个信息从半连接队列放入全连接队列中,如果在这个队列中的连接超过了超时时间,会发送重连信息,假设发送了多次之后还未连接,就会从队列中移除.

## ISN,初始序列号的随机化

初始序列号是由系统中一个随时间变化的计数器决定的,它随时间变化.



# 四次挥手

在连接的时候,需要进行三次握手,而在断开连接的时候,则是需要四次握手,这是由TCP的半关闭特性造成的,半关闭的意思就是说某一方在关闭了其发送后,还可以接收到对方的信息的状态.TCP连接的关闭需要发送4个报文,所以将其称之为四次挥手.双方均可以主动关闭请求.

1. 在一开始,双方都在`ESTABLISHED`的状态,假设由客户端首先发起断开连接请求
2. 第一次挥手:客户端发出FIN报文(FIN = 1),自身转换到`FIN_WAIT_1`状态,并停止数据发送,等待服务端回应
3. 第二次挥手:服务端收到了客户端发来的FIN报文后,会回应一个ACK报文(ACK = 1),表示收到FIN报文,并将自身状态更改为`CLOSE_WAIT`状态,此时,服务端处于半关闭的状态.而当客户端收到这个ACK后,会进入`FIN_WAIT_2`状态.
4. 第三次挥手:一般来说,服务端的应用程序如果主动调用了close()的函数后,服务端也会向客户端发送一个FIN报文(FIN = 1,ACK = 1) ,服务端进入`LAST_ACK`状态等待最后的确认
5. 第四次挥手:客户端收到了服务端发来的FIN报文后,一样会发送一个ACK报文作为响应(ACK = 1),并转为`TIME_WAIT`状态,同时服务端收到了这个ACK报文后,转入`CLOSED`状态.此时TCP连接并未完全关闭,而是等待*2MSL*后,客户端才会进入`CLOSED`状态

![](http://imageblog.boyn.top/202002011339_211.png)

## 为什么要有四次挥手

其实将4次挥手分开来,发现是双方互给对方发了一个FIN包,然后对方回应了ACK包的过程.联系TCP的半关闭的性质来看,其实FIN包说的是断开己方发送数据的通道,但是仍然可以接收对方的数据,而ACK包的回应是对方告诉连接方所有的数据已经发送完成了.

## 2MSL等待状态

`TIME_WITE`状态也被称为`2MSL`等待状态,MSL指的是(*Maximum Segment Lifetime*最大生存时间)

因为服务器发送过来的包是有可能丢失的,为了防止最后发送的ACK包丢失而导致服务端连接一直打开,客户端在发送了ACK包后不能立即关闭,如果在包丢失了,那么处于`LAST_ACK`状态的服务端会重新发送一个FIN包给客户端,这个时候要进行ACK包的重发.



TCP的状态变迁图如下:

![](http://imageblog.boyn.top/202002011337_71.png)

# 可靠传输

可靠传输有两个要求

- 保证信号不出差错
- 保证数据的准确性,无差错不重复,且顺序到达

在TCP中,使用了*连续ARQ协议*来保证数据的正确性,*滑动窗口协议*来保证接收方可以准确及时地处理数据,并可以进行流量控制,还使用了*慢开始,拥塞避免,快重传,快恢复*来进行拥塞避免

即TCP有两个比较重要的控制算法:流量控制与拥塞控制

后面将会一一说到.

## 连续ARQ协议与滑动窗口(流量控制)

ARQ,即(*Automatic Repeat-reQuest*),自动重发请求.这个协议基于确认和超时来实现可靠的信息传输.它要求对方在收到一个包后,要向己方做确认.对于一些请求可能在发送过程中会发生丢包或者超时,则会进行重传直到收到确认报文.

对于停止等待ARQ来说,一般是发一个包,等待其确认后才可以发另外一个,使得时间效率低下,基本无法使用

![](http://imageblog.boyn.top/202002011415_22.png)

而使用得更多的是连续ARQ协议,它传输如同流水线一样,传了一堆的包,等待其确认后再进行下面的传输.

![](http://imageblog.boyn.top/202002011417_968.png)

连续ARQ协议的实现离不开滑动窗口,发送方需要维持一个发送的窗口值,在一串数据中,就可以被窗口分为4个部分

1. 不在窗口中,已经传输完成并被确认的
2. 在窗口中,已经传输完成但还没有确认的
3. 在窗口中,准备进行传输的
4. 不在窗口中,准备进行传输的

同时接收方也会维持一个接收窗口,也可以被分为4个部分

1. 不在窗口中,已经确认并交付给上层
2. 未按序收到的数据
3. 允许接收的数据
4. 不允许接收的数据

![](http://imageblog.boyn.top/202002011421_857.png)

在TCP中,使用的是累积确认方式,在一系列顺序发送的包中,确认请求只需要发送最后一个按序接收的包的确认报文,就可以表示直到当前报文之前的包都已经按序收到了.

## Reno拥塞控制

Reno拥塞控制主要有4种算法:

1. 慢开始
2. 拥塞避免
3. 快重传
4. 快恢复

![](http://imageblog.boyn.top/202002011513_158.png)

### 慢开始

主机刚开始发送请求的时候,如果立刻就设置很大的窗口数,在不清楚网络状况下,有可能造成网络阻塞

所以慢启动就是从小到大逐渐增大发送端的拥塞窗口值

刚开始的时候设置为1MSS值,在每次收到一个报文确认后,将其加倍,并且这个值也会随着时间(RTT)而增大

并且我们会设置一个慢开始门限,当cwnd的值超过这个值后,就会进入拥塞避免阶段

### 拥塞避免

在慢开始中,如果不加控制,在来回几次后,cwnd的值就会变得很大,所以我们设置了一个ssthresh来避免,在这个时候,收到一个报文确认并不是加倍,而只是加一.如果在传输中出现了丢包,则分为两种情况,如果是超时丢包,那么则将cwnd设为1,重新回到慢开始阶段,而如果是连续三次收到了之前已经确认过的包,说明中间也是有丢包,但是不一定是网络拥堵引起的,这个时候,就进入快重传与快恢复状态

### 快重传与快恢复

在连续三次收到了某个包的确认信息后,可以认定在传输过程中发生了丢包,并且丢的是服务端发送过来的确认包的后面的包,所以进行快重传,立即重传后面的包并且要从这个包开始重新传输

这个时候虽然发生了丢包,但是可能并不是网络拥塞引起的丢包,所以我们无需将cwnd重新设为1,而是`ssthresh = cwnd /2 ; cwnd = ssthresh `此时直接进入了拥塞控制阶段

### 伪代码

我们要是将其写成伪代码,它的过程就会像这样

```c
cwnd = 1;  
while(1) {  
     send packets of min (cwnd, rwnd);                 // burst  
     wait until receiving all ACKs for the previous sent packets         slow-start  
     if ( timeout occurs )  break;      else   cwnd = 2*cwnd;  
}  
threshold = cwnd/2;    cwnd = 1;  
while(1){  
    if ( cwnd < threshold ){  
        send packets of min (cwnd, rwnd);              //burst  
        wait until receiving all ACKs for the previous sent packets      slow-start  
        if ( timeout occurs ){ threshold = cwnd/2;    cwnd = 1;}  
        else   cwnd = 2*cwnd;}  
        if ( cwnd == threshold || cwnd > threshold )  
            send packets of min (threshold, rwnd);     //burst  
    } else if ( cwnd > threshold ){  
        send a new packet whenever an ACK is received    //self-clocking  
        if ( Sender receives all ACKs for the previous sent packets )  
            {cwnd = cwnd + 1; send a new packet;}   //to probe more bandwidth  
        if ( timeout occurs)  
            {threshold = cwnd/2;    cwnd = 1;}          //to avoid congestion  
    }  
}  
```

